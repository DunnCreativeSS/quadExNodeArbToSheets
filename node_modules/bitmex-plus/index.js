'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitMexPlus = undefined;

var _bitmexRealtimeApi = require('bitmex-realtime-api');

var _bitmexRealtimeApi2 = _interopRequireDefault(_bitmexRealtimeApi);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BitMexPlus extends _bitmexRealtimeApi2.default {
  constructor(options) {
    super(options);
    this.options = options;
  }

  /**
   * Subscribe to a stream and call a callback for every new item
   * @param {String} [symbol='XBTUSD']
   * @param {String} tableName - e.g. 'trade', 'quote', 'orderBookL2', 'instrument' etc.
   * @param {Function} callback(data)
   */
  monitorStream(symbol = 'XBTUSD', tableName, callback) {
    let lastItem;
    this.addStream(symbol, tableName, data => {
      if (!data.length) return;
      if (tableName === 'orderBookL2') callback(); // callback must deal with the entire data array returned by getData(), no need to pass it anything
      else
        // On the first piece(s) of data, lastItem is undefined so lastIndexOf + 1 === 0.
        // Same if maxTableLen was too small (the lastItem would be splice'd out).
        for (let i = data.lastIndexOf(lastItem) + 1; i < data.length; i++) callback(data[i]);
      lastItem = data[data.length - 1];
    });
  }

  /**
   * Send a request to the BitMEX REST API. See https://www.bitmex.com/api/explorer/.
   * @param {string} verb - GET/PUT/POST/DELETE
   * @param {string} endpoint - e.g. `/user/margin`
   * @param {object} data - JSON
   * @returns {Promise<object>} - JSON response
   */
  makeRequest(verb, endpoint, data = {}) {
    const apiRoot = '/api/v1/';

    let query = '',
        postBody = '';
    if (verb === 'GET') query = '?' + _qs2.default.stringify(data);else
      // Pre-compute the postBody so we can be sure that we're using *exactly* the same body in the request
      // and in the signature. If you don't do this, you might get differently-sorted keys and blow the signature.
      postBody = JSON.stringify(data);

    const headers = {
      'content-type': 'application/json',
      'accept': 'application/json'
      // This example uses the 'expires' scheme. You can also use the 'nonce' scheme.
      // See https://www.bitmex.com/app/apiKeysUsage for more details.
    };

    if (this.options.apiKeyID && this.options.apiKeySecret) {
      const expires = new Date().getTime() + 60 * 1000; // 1 min in the future
      const signature = _crypto2.default.createHmac('sha256', this.options.apiKeySecret).update(verb + apiRoot + endpoint + query + expires + postBody).digest('hex');
      headers['api-expires'] = expires;
      headers['api-key'] = this.options.apiKeyID;
      headers['api-signature'] = signature;
    }

    const requestOptions = {
      method: verb,
      headers
    };
    if (verb !== 'GET') requestOptions.body = postBody; // GET/HEAD requests can't have body

    const apiBase = this.options.testnet ? 'https://testnet.bitmex.com' : 'https://www.bitmex.com';
    const url = apiBase + apiRoot + endpoint + query;

    return (0, _nodeFetch2.default)(url, requestOptions).then(response => response.json()).then(response => {
      if ('error' in response) throw new Error(`${response.error.message} during ${verb} ${endpoint} with ${JSON.stringify(data)}`);
      return response;
    }, error => {
      throw new Error(error);
    });
  }
}
exports.BitMexPlus = BitMexPlus;
